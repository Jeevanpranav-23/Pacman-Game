<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Pac-Man</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                background-color: black;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                font-family: 'Courier New', monospace;
                overflow: hidden;
            }

            #game-container {
                position: relative;
            }

            #board {
                background-color: black;
                display: block;
                margin: 0 auto;
            }

            #score-display {
                color: white;
                display: flex;
                justify-content: space-between;
                padding: 10px;
                font-size: 18px;
                background-color: #000;
            }

            #lives-display {
                position: absolute;
                bottom: -40px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 10px;
            }

            .life {
                width: 24px;
                height: 24px;
                background-image: url('pacmanRight.png');
                background-size: contain;
            }

            #game-message {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: yellow;
                font-size: 32px;
                font-weight: bold;
                text-align: center;
                text-shadow: 2px 2px 4px #000;
                opacity: 0;
                transition: opacity 0.5s;
                pointer-events: none;
            }

            #game-message.show {
                opacity: 1;
            }

            /* Start Screen */
            #start-screen {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 10;
                color: yellow;
            }

            #start-screen h1 {
                font-size: 48px;
                margin-bottom: 20px;
                text-shadow: 0 0 10px #ff0;
                animation: pulse 1.5s infinite;
            }

            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); }
                100% { transform: scale(1); }
            }

            #player-form {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 15px;
                margin-bottom: 30px;
            }

            #player-name {
                padding: 10px;
                font-size: 18px;
                border: 2px solid yellow;
                background: black;
                color: white;
                text-align: center;
            }

            .difficulty-buttons {
                display: flex;
                gap: 15px;
                margin-bottom: 20px;
            }

            .difficulty-btn {
                padding: 10px 20px;
                background: black;
                color: white;
                border: 2px solid;
                font-size: 16px;
                cursor: pointer;
                transition: all 0.3s;
            }

            .difficulty-btn:hover {
                transform: scale(1.1);
            }

            #easy-btn {
                border-color: #00ff00;
            }
            #easy-btn:hover {
                background: #00ff00;
                color: black;
            }

            #medium-btn {
                border-color: #ffff00;
            }
            #medium-btn:hover {
                background: #ffff00;
                color: black;
            }

            #hard-btn {
                border-color: #ff0000;
            }
            #hard-btn:hover {
                background: #ff0000;
                color: black;
            }

            #start-btn {
                padding: 15px 30px;
                background: yellow;
                color: black;
                border: none;
                font-size: 20px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s;
                margin-top: 20px;
            }

            #start-btn:hover {
                transform: scale(1.1);
                box-shadow: 0 0 20px yellow;
            }

            /* How to Play Popup */
            #how-to-play {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                border: 3px solid yellow;
                padding: 20px;
                color: white;
                max-width: 80%;
                max-height: 80%;
                overflow-y: auto;
                z-index: 20;
                display: none;
            }

            #how-to-play h2 {
                color: yellow;
                text-align: center;
                margin-top: 0;
            }

            #how-to-play-close {
                position: absolute;
                top: 10px;
                right: 10px;
                background: none;
                border: none;
                color: white;
                font-size: 20px;
                cursor: pointer;
            }

            /* High Scores Table */
            #high-scores {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                border: 3px solid yellow;
                padding: 20px;
                color: white;
                max-width: 80%;
                max-height: 80%;
                overflow-y: auto;
                z-index: 20;
                display: none;
            }

            #high-scores h2 {
                color: yellow;
                text-align: center;
                margin-top: 0;
            }

            #high-scores-close {
                position: absolute;
                top: 10px;
                right: 10px;
                background: none;
                border: none;
                color: white;
                font-size: 20px;
                cursor: pointer;
            }

            #scores-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 15px;
            }

            #scores-table th {
                background: yellow;
                color: black;
                padding: 8px;
                text-align: left;
            }

            #scores-table td {
                padding: 8px;
                border-bottom: 1px solid #333;
            }

            #scores-table tr:nth-child(even) {
                background: rgba(255, 255, 0, 0.1);
            }

            /* Timer Display */
            #timer-display {
                position: absolute;
                top: 10px;
                right: 10px;
                color: white;
                font-size: 18px;
                background: rgba(0, 0, 0, 0.7);
                padding: 5px 10px;
                border-radius: 5px;
                display: none;
            }

            /* Mobile Controls */
            #mobile-controls {
                position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: none;
                grid-template-areas:
                    ". up ."
                    "left . right"
                    ". down .";
                gap: 10px;
            }

            .mobile-btn {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: rgba(255, 255, 0, 0.3);
                border: 2px solid yellow;
                color: white;
                font-size: 24px;
                display: flex;
                justify-content: center;
                align-items: center;
                cursor: pointer;
                user-select: none;
            }

            .mobile-btn:active {
                background: rgba(255, 255, 0, 0.7);
            }

            #up-btn { grid-area: up; }
            #down-btn { grid-area: down; }
            #left-btn { grid-area: left; }
            #right-btn { grid-area: right; }

            /* Game Overlay Buttons */
            #game-buttons {
                position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                gap: 15px;
                z-index: 5;
            }

            .game-btn {
                padding: 8px 15px;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                border: 2px solid yellow;
                border-radius: 5px;
                cursor: pointer;
            }

            /* Confetti Effect */
            .confetti {
                position: absolute;
                width: 10px;
                height: 10px;
                background-color: #f00;
                opacity: 0;
                z-index: 15;
                animation: confetti-fall 3s ease-in-out forwards;
            }

            @keyframes confetti-fall {
                0% {
                    transform: translateY(-100vh) rotate(0deg);
                    opacity: 1;
                }
                100% {
                    transform: translateY(100vh) rotate(360deg);
                    opacity: 0;
                }
            }

            /* Fruit Bonus */
            .fruit-bonus {
                position: absolute;
                font-size: 24px;
                color: yellow;
                opacity: 0;
                animation: bonus-fade 1.5s forwards;
                z-index: 5;
            }

            @keyframes bonus-fade {
                0% {
                    transform: translateY(0);
                    opacity: 1;
                }
                100% {
                    transform: translateY(-50px);
                    opacity: 0;
                }
            }
        </style>
    </head>
    <body>
        <div id="game-container">
            <div id="score-display">
                <span id="score">0</span>
                <span id="high-score">HIGH: 0</span>
                <span id="level">LEVEL: 1</span>
            </div>
            <canvas id="board"></canvas>
            <div id="lives-display"></div>
            <div id="game-message"></div>
            <div id="timer-display">TIME: 0:00</div>

            <!-- Game Overlay Buttons -->
            <div id="game-buttons">
                <button id="how-to-play-btn" class="game-btn">How to Play</button>
                <button id="high-scores-btn" class="game-btn">High Scores</button>
            </div>

            <!-- Mobile Controls -->
            <div id="mobile-controls">
                <div id="up-btn" class="mobile-btn">↑</div>
                <div id="left-btn" class="mobile-btn">←</div>
                <div id="right-btn" class="mobile-btn">→</div>
                <div id="down-btn" class="mobile-btn">↓</div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen">
            <h1>PAC-MAN</h1>
            <div id="player-form">
                <input type="text" id="player-name" placeholder="Enter your name" maxlength="15" required>
                <div class="difficulty-buttons">
                    <button id="easy-btn" class="difficulty-btn">Easy</button>
                    <button id="medium-btn" class="difficulty-btn">Medium</button>
                    <button id="hard-btn" class="difficulty-btn">Hard</button>
                </div>
            </div>
            <button id="start-btn">START GAME</button>
            <button id="view-scores-btn" class="game-btn">View High Scores</button>
        </div>

        <!-- How to Play Popup -->
        <div id="how-to-play">
            <button id="how-to-play-close">&times;</button>
            <h2>HOW TO PLAY</h2>
            <h3>Desktop Controls:</h3>
            <p>↑ or W - Move Up</p>
            <p>↓ or S - Move Down</p>
            <p>← or A - Move Left</p>
            <p>→ or D - Move Right</p>
            <p>SPACE - Restart after Game Over</p>
            
            <h3>Mobile Controls:</h3>
            <p>Use the on-screen directional buttons to move Pac-Man</p>
            
            <h3>Game Rules:</h3>
            <p>- Eat all the dots to advance to the next level</p>
            <p>- Big dots make ghosts vulnerable for a short time</p>
            <p>- Eating a vulnerable ghost gives bonus points</p>
            <p>- Avoid ghosts when they're not vulnerable</p>
            
            <h3>Difficulty Levels:</h3>
            <p><strong>Easy:</strong> Slower ghosts, longer power pellet duration</p>
            <p><strong>Medium:</strong> Standard speed and duration</p>
            <p><strong>Hard:</strong> Faster ghosts, shorter power pellet duration</p>
        </div>

        <!-- High Scores Table -->
        <div id="high-scores">
            <button id="high-scores-close">&times;</button>
            <h2>HIGH SCORES</h2>
            <table id="scores-table">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Player</th>
                        <th>Score</th>
                        <th>Level</th>
                        <th>Mode</th>
                        <th>Date</th>
                    </tr>
                </thead>
                <tbody id="scores-body">
                    <!-- Scores will be inserted here -->
                </tbody>
            </table>
        </div>

        <!-- Audio Elements -->
        <audio id="eat-sound" src="sounds/eat.wav" preload="auto"></audio>
        <audio id="power-pellet-sound" src="sounds/power_pellet.wav" preload="auto"></audio>
        <audio id="ghost-eaten-sound" src="sounds/ghost_eaten.wav" preload="auto"></audio>
        <audio id="death-sound" src="sounds/death.wav" preload="auto"></audio>
        <audio id="game-start-sound" src="sounds/game_start.wav" preload="auto"></audio>
        <audio id="win-sound" src="sounds/win.wav" preload="auto"></audio>
        <audio id="level-up-sound" src="sounds/level_up.wav" preload="auto"></audio>

        <script>
            // Game Constants
            const rowCount = 21;
            const columnCount = 19;
            const tileSize = 32;
            const boardWidth = columnCount * tileSize;
            const boardHeight = rowCount * tileSize;

            // Game State
            let board, context;
            let gameOver = false;
            let score = 0;
            let highScore = 0;
            let lives = 3;
            let level = 1;
            let pelletsEaten = 0;
            let totalPellets = 0;
            let frightenedMode = false;
            let frightenedTimer = 0;
            let gameStarted = false;
            let playerName = "";
            let difficulty = "medium";
            let gameTimer = 0;
            let timerInterval;
            let FRIGHTENED_DURATION = 10000; // 10 seconds (default for medium)

            // Game Objects
            let pacman;
            const walls = new Set();
            const foods = new Set();
            const powerPellets = new Set();
            const ghosts = new Set();

            // Images
            let wallImage;
            let blueGhostImage, orangeGhostImage, pinkGhostImage, redGhostImage;
            let blueGhostFrightenedImage, whiteGhostFrightenedImage;
            let pacmanImages = {
                up: [], down: [], left: [], right: [],
                death: []
            };
            let lifeImage;

            // Sounds
            let eatSound, powerPelletSound, ghostEatenSound, deathSound, gameStartSound, winSound, levelUpSound;

            // Tile Map
            const tileMap = [
                "XXXXXXXXXXXXXXXXXXX",
                "X        X        X",
                "X XX XXX X XXX XX X",
                "X                 X",
                "X XX X XXXXX X XX X",
                "X    X       X    X",
                "XXXX XXXX XXXX XXXX",
                "OOOX X       X XOOO",
                "XXXX X XXrXX X XXXX",
                "O       bpo       O",
                "XXXX X XXXXX X XXXX",
                "OOOX X       X XOOO",
                "XXXX X XXXXX X XXXX",
                "X        X        X",
                "X XX XXX X XXX XX X",
                "X  X     P     X  X",
                "XX X X XXXXX X X XX",
                "X    X   X   X    X",
                "X XXXXXX X XXXXXX X",
                "X                 X",
                "XXXXXXXXXXXXXXXXXXX" 
            ];

            // Ghost House Positions
            const GHOST_HOUSE_ENTRANCE = { x: 9 * tileSize, y: 9 * tileSize };
            const GHOST_HOUSE_CENTER = { x: 9 * tileSize, y: 8 * tileSize };

            // Game Initialization
            window.onload = function() {
                board = document.getElementById("board");
                board.height = boardHeight;
                board.width = boardWidth;
                context = board.getContext("2d");

                // Load sounds
                eatSound = document.getElementById("eat-sound");
                powerPelletSound = document.getElementById("power-pellet-sound");
                ghostEatenSound = document.getElementById("ghost-eaten-sound");
                deathSound = document.getElementById("death-sound");
                gameStartSound = document.getElementById("game-start-sound");
                winSound = document.getElementById("win-sound");
                levelUpSound = document.getElementById("level-up-sound");

                // Event listeners for start screen
                document.getElementById("start-btn").addEventListener("click", startGameFromScreen);
                document.getElementById("easy-btn").addEventListener("click", () => setDifficulty("easy"));
                document.getElementById("medium-btn").addEventListener("click", () => setDifficulty("medium"));
                document.getElementById("hard-btn").addEventListener("click", () => setDifficulty("hard"));
                document.getElementById("view-scores-btn").addEventListener("click", showHighScores);
                document.getElementById("how-to-play-btn").addEventListener("click", showHowToPlay);
                document.getElementById("high-scores-btn").addEventListener("click", showHighScores);
                document.getElementById("how-to-play-close").addEventListener("click", hideHowToPlay);
                document.getElementById("high-scores-close").addEventListener("click", hideHighScores);

                // Mobile controls
                document.getElementById("up-btn").addEventListener("touchstart", () => pacman.updateDirection('up'));
                document.getElementById("down-btn").addEventListener("touchstart", () => pacman.updateDirection('down'));
                document.getElementById("left-btn").addEventListener("touchstart", () => pacman.updateDirection('left'));
                document.getElementById("right-btn").addEventListener("touchstart", () => pacman.updateDirection('right'));

                // Check if mobile device
                if (/Mobi|Android/i.test(navigator.userAgent)) {
                    document.getElementById("mobile-controls").style.display = "grid";
                }

                // Load high scores from localStorage
                loadHighScores();

                // Set default difficulty
                setDifficulty("medium");
            };

            function setDifficulty(level) {
                difficulty = level;
                
                // Reset active buttons
                document.getElementById("easy-btn").style.background = "black";
                document.getElementById("medium-btn").style.background = "black";
                document.getElementById("hard-btn").style.background = "black";
                
                // Highlight selected difficulty
                switch(level) {
                    case "easy":
                        document.getElementById("easy-btn").style.background = "#00ff00";
                        FRIGHTENED_DURATION = 15000; // 15 seconds
                        break;
                    case "medium":
                        document.getElementById("medium-btn").style.background = "#ffff00";
                        FRIGHTENED_DURATION = 10000; // 10 seconds
                        break;
                    case "hard":
                        document.getElementById("hard-btn").style.background = "#ff0000";
                        FRIGHTENED_DURATION = 5000; // 5 seconds
                        break;
                }
            }

            function startGameFromScreen() {
                const nameInput = document.getElementById("player-name");
                if (!nameInput.value.trim()) {
                    alert("Please enter your name!");
                    return;
                }
                
                playerName = nameInput.value.trim();
                document.getElementById("start-screen").style.display = "none";
                document.getElementById("timer-display").style.display = "block";
                
                startTimer();
                loadImages();
                loadMap();
                updateLivesDisplay();
                showMessage("READY!", 2000, startGame);
            }

            function startTimer() {
                gameTimer = 0;
                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    gameTimer += 1;
                    const minutes = Math.floor(gameTimer / 60);
                    const seconds = gameTimer % 60;
                    document.getElementById("timer-display").textContent = 
                        `TIME: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                }, 1000);
            }

            function stopTimer() {
                clearInterval(timerInterval);
            }

            function loadImages() {
                // Load wall image
                wallImage = new Image();
                wallImage.src = "./wall.png";

                // Load ghost images
                blueGhostImage = new Image();
                blueGhostImage.src = "./blueGhost.png";
                orangeGhostImage = new Image();
                orangeGhostImage.src = "./orangeGhost.png";
                pinkGhostImage = new Image();
                pinkGhostImage.src = "./pinkGhost.png";
                redGhostImage = new Image();
                redGhostImage.src = "./redGhost.png";
                
                // Load frightened ghost images
                blueGhostFrightenedImage = new Image();
                blueGhostFrightenedImage.src = "./blueGhostFrightened.png";
                whiteGhostFrightenedImage = new Image();
                whiteGhostFrightenedImage.src = "./whiteGhostFrightened.png";

                // Load Pac-Man animation frames
                for (let i = 0; i < 4; i++) {
                    pacmanImages.up[i] = new Image();
                    pacmanImages.up[i].src = `./pacmanUp${i}.png`;
                    pacmanImages.down[i] = new Image();
                    pacmanImages.down[i].src = `./pacmanDown${i}.png`;
                    pacmanImages.left[i] = new Image();
                    pacmanImages.left[i].src = `./pacmanLeft${i}.png`;
                    pacmanImages.right[i] = new Image();
                    pacmanImages.right[i].src = `./pacmanRight${i}.png`;
                }

                // Load life icon
                lifeImage = new Image();
                lifeImage.src = "./pacmanRight.png";
            }

            function loadMap() {
                walls.clear();
                foods.clear();
                powerPellets.clear();
                ghosts.clear();
                totalPellets = 0;

                for (let r = 0; r < rowCount; r++) {
                    for (let c = 0; c < columnCount; c++) {
                        const tileMapChar = tileMap[r][c];
                        const x = c * tileSize;
                        const y = r * tileSize;

                        if (tileMapChar == 'X') {
                            walls.add(new Block(wallImage, x, y, tileSize, tileSize));
                        }
                        else if (tileMapChar == 'b') {
                            ghosts.add(new Ghost(blueGhostImage, x, y, 'blue', 'chase'));
                        }
                        else if (tileMapChar == 'o') {
                            ghosts.add(new Ghost(orangeGhostImage, x, y, 'orange', 'scatter'));
                        }
                        else if (tileMapChar == 'p') {
                            ghosts.add(new Ghost(pinkGhostImage, x, y, 'pink', 'scatter'));
                        }
                        else if (tileMapChar == 'r') {
                            ghosts.add(new Ghost(redGhostImage, x, y, 'red', 'chase'));
                        }
                        else if (tileMapChar == 'P') {
                            pacman = new PacMan(x, y);
                        }
                        else if (tileMapChar == ' ') {
                            foods.add(new Block(null, x + 14, y + 14, 4, 4));
                            totalPellets++;
                        }
                        else if (tileMapChar == 'O') {
                            powerPellets.add(new Block(null, x + 8, y + 8, 16, 16));
                            totalPellets++;
                        }
                    }
                }

                // Adjust ghost speed based on difficulty
                const baseSpeed = tileSize / 10;
                for (let ghost of ghosts) {
                    switch(difficulty) {
                        case "easy":
                            ghost.speed = baseSpeed * 0.8;
                            break;
                        case "medium":
                            ghost.speed = baseSpeed;
                            break;
                        case "hard":
                            ghost.speed = baseSpeed * 1.2;
                            break;
                    }
                }
            }

            function startGame() {
                gameStarted = true;
                gameStartSound.play();
                update();
            }

            // Game Loop
            function update() {
                if (gameOver) return;

                // Update game state
                updateGameState();
                
                // Move characters
                moveCharacters();
                
                // Check collisions
                checkCollisions();
                
                // Draw everything
                draw();
                
                // Continue game loop
                requestAnimationFrame(update);
            }

            function updateGameState() {
                // Update frightened mode timer
                if (frightenedMode) {
                    frightenedTimer -= 16; // Assuming ~60fps
                    if (frightenedTimer <= 0) {
                        endFrightenedMode();
                    } else if (frightenedTimer <= 2000) { // Last 2 seconds - blinking
                        for (let ghost of ghosts) {
                            ghost.blinking = Math.floor(frightenedTimer / 200) % 2 === 0;
                        }
                    }
                }
            }

            function moveCharacters() {
                // Move Pac-Man
                pacman.move();
                
                // Move ghosts
                for (let ghost of ghosts) {
                    ghost.move();
                }
            }

            function checkCollisions() {
                checkWallCollisions();
                checkGhostCollisions();
                checkFoodCollisions();
                checkPowerPelletCollisions();
                checkLevelCompletion();
            }

            function draw() {
                // Clear canvas
                context.clearRect(0, 0, board.width, board.height);
                
                // Draw walls
                for (let wall of walls) {
                    context.drawImage(wall.image, wall.x, wall.y, wall.width, wall.height);
                }
                
                // Draw food
                context.fillStyle = "white";
                for (let food of foods) {
                    context.beginPath();
                    context.arc(food.x + food.width/2, food.y + food.height/2, food.width/2, 0, Math.PI * 2);
                    context.fill();
                }
                
                // Draw power pellets
                context.fillStyle = "white";
                for (let pellet of powerPellets) {
                    context.beginPath();
                    context.arc(pellet.x + pellet.width/2, pellet.y + pellet.height/2, pellet.width/2, 0, Math.PI * 2);
                    context.fill();
                }
                
                // Draw ghosts
                for (let ghost of ghosts) {
                    ghost.draw();
                }
                
                // Draw Pac-Man
                pacman.draw();
                
                // Update score display
                document.getElementById("score").textContent = score;
                document.getElementById("high-score").textContent = `HIGH: ${highScore}`;
                document.getElementById("level").textContent = `LEVEL: ${level}`;
            }

            // Game Classes
            class Block {
                constructor(image, x, y, width, height) {
                    this.image = image;
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.startX = x;
                    this.startY = y;
                }

                reset() {
                    this.x = this.startX;
                    this.y = this.startY;
                }
            }

            class PacMan extends Block {
                constructor(x, y) {
                    super(null, x, y, tileSize, tileSize);
                    this.direction = 'right';
                    this.nextDirection = 'right';
                    this.velocityX = 0;
                    this.velocityY = 0;
                    this.speed = tileSize / 8;
                    this.animationFrame = 0;
                    this.animationTimer = 0;
                    this.isAlive = true;
                }

                updateDirection(newDirection) {
                    this.nextDirection = newDirection;
                }

                move() {
                    // Try to change direction if requested
                    if (this.direction !== this.nextDirection) {
                        const originalDirection = this.direction;
                        this.direction = this.nextDirection;
                        this.updateVelocity();
                        
                        // Check if new direction is valid
                        this.x += this.velocityX;
                        this.y += this.velocityY;
                        
                        let canMove = true;
                        for (let wall of walls) {
                            if (collision(this, wall)) {
                                canMove = false;
                                break;
                            }
                        }
                        
                        if (!canMove) {
                            this.direction = originalDirection;
                            this.updateVelocity();
                        }
                        
                        this.x -= this.velocityX;
                        this.y -= this.velocityY;
                    }
                    
                    // Move in current direction
                    this.x += this.velocityX;
                    this.y += this.velocityY;
                    
                    // Wrap around tunnel
                    if (this.x < -this.width) {
                        this.x = boardWidth;
                    } else if (this.x > boardWidth) {
                        this.x = -this.width;
                    }
                    
                    // Animation
                    this.animationTimer++;
                    if (this.animationTimer >= 5) {
                        this.animationTimer = 0;
                        this.animationFrame = (this.animationFrame + 1) % 4;
                    }
                }

                updateVelocity() {
                    switch (this.direction) {
                        case 'up':
                            this.velocityX = 0;
                            this.velocityY = -this.speed;
                            break;
                        case 'down':
                            this.velocityX = 0;
                            this.velocityY = this.speed;
                            break;
                        case 'left':
                            this.velocityX = -this.speed;
                            this.velocityY = 0;
                            break;
                        case 'right':
                            this.velocityX = this.speed;
                            this.velocityY = 0;
                            break;
                    }
                }

                draw() {
                    if (!this.isAlive) return;
                    
                    let img;
                    switch (this.direction) {
                        case 'up':
                            img = pacmanImages.up[this.animationFrame];
                            break;
                        case 'down':
                            img = pacmanImages.down[this.animationFrame];
                            break;
                        case 'left':
                            img = pacmanImages.left[this.animationFrame];
                            break;
                        case 'right':
                            img = pacmanImages.right[this.animationFrame];
                            break;
                    }
                    
                    context.drawImage(img, this.x, this.y, this.width, this.height);
                }

                die() {
                    this.isAlive = false;
                    deathSound.play();
                    lives--;
                    updateLivesDisplay();
                    
                    if (lives <= 0) {
                        gameOver = true;
                        stopTimer();
                        saveHighScore();
                        showMessage("GAME OVER", 2000, resetGame);
                    } else {
                        showMessage("READY!", 1500, resetPositions);
                    }
                }
            }

            class Ghost extends Block {
                constructor(image, x, y, color, behavior) {
                    super(image, x, y, tileSize, tileSize);
                    this.color = color;
                    this.originalImage = image;
                    this.direction = this.getRandomDirection();
                    this.velocityX = 0;
                    this.velocityY = 0;
                    this.speed = tileSize / 10;
                    this.behavior = behavior;
                    this.behaviorTimer = 0;
                    this.target = { x: 0, y: 0 };
                    this.blinking = false;
                    this.isFrightened = false;
                    this.isEaten = false;
                    this.updateVelocity();
                }

                move() {
                    if (this.isEaten && this.x === GHOST_HOUSE_CENTER.x && this.y === GHOST_HOUSE_CENTER.y) {
                        this.isEaten = false;
                        this.isFrightened = false;
                        this.image = this.originalImage;
                        return;
                    }
                    
                    // Update behavior timer
                    this.behaviorTimer += 16;
                    if (this.behaviorTimer >= 7000) { // Change behavior every 7 seconds
                        this.behaviorTimer = 0;
                        this.behavior = this.behavior === 'chase' ? 'scatter' : 'chase';
                    }
                    
                    // Set target based on behavior
                    if (this.isEaten) {
                        this.target = GHOST_HOUSE_CENTER;
                    } else if (this.isFrightened) {
                        // Random movement when frightened
                        if (Math.random() < 0.05 || this.atIntersection()) {
                            this.direction = this.getRandomDirection();
                        }
                    } else {
                        switch (this.behavior) {
                            case 'chase':
                                this.setChaseTarget();
                                break;
                            case 'scatter':
                                this.setScatterTarget();
                                break;
                        }
                        
                        // Change direction at intersections
                        if (this.atIntersection()) {
                            const possibleDirections = this.getPossibleDirections();
                            let bestDirection = this.direction;
                            let bestDistance = Infinity;
                            
                            for (let dir of possibleDirections) {
                                if (dir === this.getOppositeDirection()) continue;
                                
                                let x = this.x, y = this.y;
                                switch (dir) {
                                    case 'up': y -= this.speed; break;
                                    case 'down': y += this.speed; break;
                                    case 'left': x -= this.speed; break;
                                    case 'right': x += this.speed; break;
                                }
                                
                                const dist = Math.sqrt(Math.pow(x - this.target.x, 2) + Math.pow(y - this.target.y, 2));
                                if (dist < bestDistance) {
                                    bestDistance = dist;
                                    bestDirection = dir;
                                }
                            }
                            
                            this.direction = bestDirection;
                        }
                    }
                    
                    // Move in current direction
                    this.updateVelocity();
                    this.x += this.velocityX;
                    this.y += this.velocityY;
                    
                    // Wrap around tunnel
                    if (this.x < -this.width) {
                        this.x = boardWidth;
                    } else if (this.x > boardWidth) {
                        this.x = -this.width;
                    }
                }

                atIntersection() {
                    // Check if ghost is at a position where it can change direction
                    const centerX = this.x + this.width/2;
                    const centerY = this.y + this.height/2;
                    return Math.abs(centerX % tileSize) < 2 && Math.abs(centerY % tileSize) < 2;
                }

                getPossibleDirections() {
                    const directions = ['up', 'down', 'left', 'right'];
                    return directions.filter(dir => {
                        // Check if direction is valid (not blocked by wall)
                        let x = this.x, y = this.y;
                        switch (dir) {
                            case 'up': y -= this.speed; break;
                            case 'down': y += this.speed; break;
                            case 'left': x -= this.speed; break;
                            case 'right': x += this.speed; break;
                        }
                        
                        const tempBlock = new Block(null, x, y, this.width, this.height);
                        for (let wall of walls) {
                            if (collision(tempBlock, wall)) {
                                return false;
                            }
                        }
                        return true;
                    });
                }

                getRandomDirection() {
                    const directions = this.getPossibleDirections();
                    return directions[Math.floor(Math.random() * directions.length)];
                }

                            getOppositeDirection() {
                    switch (this.direction) {
                        case 'up': return 'down';
                        case 'down': return 'up';
                        case 'left': return 'right';
                        case 'right': return 'left';
                        default: return this.direction;
                    }
                }

                updateVelocity() {
                    switch (this.direction) {
                        case 'up':
                            this.velocityX = 0;
                            this.velocityY = -this.speed;
                            break;
                        case 'down':
                            this.velocityX = 0;
                            this.velocityY = this.speed;
                            break;
                        case 'left':
                            this.velocityX = -this.speed;
                            this.velocityY = 0;
                            break;
                        case 'right':
                            this.velocityX = this.speed;
                            this.velocityY = 0;
                            break;
                    }
                }

                setChaseTarget() {
                    // Each ghost has different chase behavior
                    switch (this.color) {
                        case 'red': // Blinky - chases directly
                            this.target = { x: pacman.x, y: pacman.y };
                            break;
                        case 'pink': // Pinky - targets 4 tiles ahead of Pac-Man
                            let aheadX = pacman.x, aheadY = pacman.y;
                            switch (pacman.direction) {
                                case 'up': aheadY -= tileSize * 4; break;
                                case 'down': aheadY += tileSize * 4; break;
                                case 'left': aheadX -= tileSize * 4; break;
                                case 'right': aheadX += tileSize * 4; break;
                            }
                            this.target = { x: aheadX, y: aheadY };
                            break;
                        case 'blue': // Inky - uses complex targeting
                            // Targets tile that is vector from Blinky to 2 tiles ahead of Pac-Man
                            let blinky = Array.from(ghosts).find(g => g.color === 'red');
                            if (!blinky) blinky = { x: 0, y: 0 };
                            
                            let pacmanAheadX = pacman.x, pacmanAheadY = pacman.y;
                            switch (pacman.direction) {
                                case 'up': pacmanAheadY -= tileSize * 2; break;
                                case 'down': pacmanAheadY += tileSize * 2; break;
                                case 'left': pacmanAheadX -= tileSize * 2; break;
                                case 'right': pacmanAheadX += tileSize * 2; break;
                            }
                            
                            const vectorX = pacmanAheadX - blinky.x;
                            const vectorY = pacmanAheadY - blinky.y;
                            
                            this.target = {
                                x: pacmanAheadX + vectorX,
                                y: pacmanAheadY + vectorY
                            };
                            break;
                        case 'orange': // Clyde - chases unless too close
                            const distance = Math.sqrt(
                                Math.pow(this.x - pacman.x, 2) + 
                                Math.pow(this.y - pacman.y, 2)
                            );
                            
                            if (distance < tileSize * 8) {
                                // Scatter to bottom left corner
                                this.target = { x: 0, y: boardHeight };
                            } else {
                                this.target = { x: pacman.x, y: pacman.y };
                            }
                            break;
                    }
                }

                setScatterTarget() {
                    // Each ghost has a different corner they target in scatter mode
                    switch (this.color) {
                        case 'red': // Top right
                            this.target = { x: boardWidth, y: 0 };
                            break;
                        case 'pink': // Top left
                            this.target = { x: 0, y: 0 };
                            break;
                        case 'blue': // Bottom right
                            this.target = { x: boardWidth, y: boardHeight };
                            break;
                        case 'orange': // Bottom left
                            this.target = { x: 0, y: boardHeight };
                            break;
                    }
                }

                draw() {
                    if (this.isEaten) {
                        // Draw eyes only when eaten
                        context.fillStyle = "white";
                        context.beginPath();
                        context.arc(this.x + this.width/3, this.y + this.height/3, 5, 0, Math.PI * 2);
                        context.arc(this.x + this.width*2/3, this.y + this.height/3, 5, 0, Math.PI * 2);
                        context.fill();
                    } else if (this.isFrightened) {
                        // Draw frightened ghost
                        if (this.blinking) {
                            context.drawImage(whiteGhostFrightenedImage, this.x, this.y, this.width, this.height);
                        } else {
                            context.drawImage(blueGhostFrightenedImage, this.x, this.y, this.width, this.height);
                        }
                    } else {
                        // Draw normal ghost
                        context.drawImage(this.image, this.x, this.y, this.width, this.height);
                    }
                    
                    // Draw eyes (direction indicator)
                    if (!this.isFrightened) {
                        context.fillStyle = "white";
                        // Left eye
                        context.beginPath();
                        context.arc(
                            this.x + this.width/3 + (this.direction === 'left' ? -2 : this.direction === 'right' ? 2 : 0),
                            this.y + this.height/3 + (this.direction === 'up' ? -2 : this.direction === 'down' ? 2 : 0),
                            5, 0, Math.PI * 2
                        );
                        context.fill();
                        
                        // Right eye
                        context.beginPath();
                        context.arc(
                            this.x + this.width*2/3 + (this.direction === 'left' ? -2 : this.direction === 'right' ? 2 : 0),
                            this.y + this.height/3 + (this.direction === 'up' ? -2 : this.direction === 'down' ? 2 : 0),
                            5, 0, Math.PI * 2
                        );
                        context.fill();
                        
                        // Pupils
                        context.fillStyle = "blue";
                        // Left pupil
                        context.beginPath();
                        context.arc(
                            this.x + this.width/3 + (this.direction === 'left' ? -4 : this.direction === 'right' ? 4 : 0),
                            this.y + this.height/3 + (this.direction === 'up' ? -4 : this.direction === 'down' ? 4 : 0),
                            2, 0, Math.PI * 2
                        );
                        context.fill();
                        
                        // Right pupil
                        context.beginPath();
                        context.arc(
                            this.x + this.width*2/3 + (this.direction === 'left' ? -4 : this.direction === 'right' ? 4 : 0),
                            this.y + this.height/3 + (this.direction === 'up' ? -4 : this.direction === 'down' ? 4 : 0),
                            2, 0, Math.PI * 2
                        );
                        context.fill();
                    }
                }

                eat() {
                    this.isEaten = true;
                    this.isFrightened = false;
                    ghostEatenSound.play();
                    
                    // Calculate score based on how many ghosts have been eaten in this frightened mode
                    const eatenGhosts = Array.from(ghosts).filter(g => g.isEaten).length;
                    const points = [200, 400, 800, 1600][Math.min(eatenGhosts - 1, 3)];
                    score += points;
                    
                    // Show bonus text
                    showBonusText(points, this.x, this.y);
                }
            }

            // Helper Functions
            function collision(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }

            function checkWallCollisions() {
                // Check Pac-Man wall collisions
                for (let wall of walls) {
                    if (collision(pacman, wall)) {
                        // Move Pac-Man back
                        pacman.x -= pacman.velocityX;
                        pacman.y -= pacman.velocityY;
                        break;
                    }
                }
                
                // Check ghost wall collisions
                for (let ghost of ghosts) {
                    if (ghost.isEaten) continue;
                    
                    for (let wall of walls) {
                        if (collision(ghost, wall)) {
                            // Move ghost back
                            ghost.x -= ghost.velocityX;
                            ghost.y -= ghost.velocityY;
                            
                            // Choose new direction
                            if (!ghost.isFrightened) {
                                const possibleDirections = ghost.getPossibleDirections();
                                if (possibleDirections.length > 0) {
                                    ghost.direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
                                }
                            }
                            break;
                        }
                    }
                }
            }

            function checkGhostCollisions() {
                if (!pacman.isAlive) return;
                
                for (let ghost of ghosts) {
                    if (collision(pacman, ghost)) {
                        if (ghost.isFrightened && !ghost.isEaten) {
                            ghost.eat();
                        } else if (!ghost.isFrightened && !ghost.isEaten) {
                            pacman.die();
                            break;
                        }
                    }
                }
            }

            function checkFoodCollisions() {
                for (let food of foods) {
                    if (collision(pacman, food)) {
                        foods.delete(food);
                        eatSound.play();
                        score += 10;
                        pelletsEaten++;
                        break;
                    }
                }
            }

            function checkPowerPelletCollisions() {
                for (let pellet of powerPellets) {
                    if (collision(pacman, pellet)) {
                        powerPellets.delete(pellet);
                        powerPelletSound.play();
                        score += 50;
                        pelletsEaten++;
                        startFrightenedMode();
                        break;
                    }
                }
            }

            function startFrightenedMode() {
                frightenedMode = true;
                frightenedTimer = FRIGHTENED_DURATION;
                
                for (let ghost of ghosts) {
                    if (!ghost.isEaten) {
                        ghost.isFrightened = true;
                        ghost.blinking = false;
                    }
                }
            }

            function endFrightenedMode() {
                frightenedMode = false;
                
                for (let ghost of ghosts) {
                    ghost.isFrightened = false;
                    ghost.blinking = false;
                }
            }

            function checkLevelCompletion() {
                if (pelletsEaten >= totalPellets) {
                    levelComplete();
                }
            }

            function levelComplete() {
                gameStarted = false;
                stopTimer();
                winSound.play();
                level++;
                
                // Increase difficulty slightly
                pacman.speed *= 1.05;
                for (let ghost of ghosts) {
                    ghost.speed *= 1.03;
                }
                
                // Reset pellets
                pelletsEaten = 0;
                loadMap();
                
                // Show level complete message
                showMessage(`LEVEL ${level-1} COMPLETE!`, 2000, () => {
                    levelUpSound.play();
                    showMessage("READY!", 1500, startGame);
                });
            }

            function resetPositions() {
                pacman.reset();
                pacman.isAlive = true;
                pacman.direction = 'right';
                pacman.nextDirection = 'right';
                pacman.updateVelocity();
                
                for (let ghost of ghosts) {
                    ghost.reset();
                    ghost.isFrightened = false;
                    ghost.isEaten = false;
                    ghost.image = ghost.originalImage;
                    ghost.direction = ghost.getRandomDirection();
                }
            }

            function resetGame() {
                gameOver = false;
                score = 0;
                lives = 3;
                level = 1;
                pelletsEaten = 0;
                
                // Reset speeds
                pacman.speed = tileSize / 8;
                const baseSpeed = tileSize / 10;
                for (let ghost of ghosts) {
                    ghost.speed = baseSpeed;
                }
                
                loadMap();
                updateLivesDisplay();
                resetPositions();
                
                // Return to start screen
                document.getElementById("start-screen").style.display = "flex";
                document.getElementById("timer-display").style.display = "none";
            }

            function updateLivesDisplay() {
                const livesDisplay = document.getElementById("lives-display");
                livesDisplay.innerHTML = '';
                
                for (let i = 0; i < lives; i++) {
                    const life = document.createElement("div");
                    life.className = "life";
                    life.style.backgroundImage = `url('pacmanRight.png')`;
                    livesDisplay.appendChild(life);
                }
            }

            function showMessage(text, duration, callback) {
                const message = document.getElementById("game-message");
                message.textContent = text;
                message.classList.add("show");
                
                setTimeout(() => {
                    message.classList.remove("show");
                    if (callback) setTimeout(callback, 500);
                }, duration);
            }

            function showBonusText(points, x, y) {
                const bonus = document.createElement("div");
                bonus.className = "fruit-bonus";
                bonus.textContent = points;
                bonus.style.left = `${x}px`;
                bonus.style.top = `${y}px`;
                document.getElementById("game-container").appendChild(bonus);
                
                setTimeout(() => {
                    bonus.remove();
                }, 1500);
            }

            function createConfetti() {
                const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
                
                for (let i = 0; i < 100; i++) {
                    const confetti = document.createElement("div");
                    confetti.className = "confetti";
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = `${Math.random() * 100}%`;
                    confetti.style.animationDelay = `${Math.random() * 2}s`;
                    document.getElementById("game-container").appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 3000);
                }
            }

            function showHowToPlay() {
                document.getElementById("how-to-play").style.display = "block";
            }

            function hideHowToPlay() {
                document.getElementById("how-to-play").style.display = "none";
            }

            function showHighScores() {
                document.getElementById("high-scores").style.display = "block";
                renderHighScores();
            }

            function hideHighScores() {
                document.getElementById("high-scores").style.display = "none";
            }

            function loadHighScores() {
                const scores = JSON.parse(localStorage.getItem('pacmanHighScores')) || [];
                highScore = scores.length > 0 ? scores[0].score : 0;
                document.getElementById("high-score").textContent = `HIGH: ${highScore}`;
            }

            function saveHighScore() {
                if (score === 0) return;
                
                const scores = JSON.parse(localStorage.getItem('pacmanHighScores')) || [];
                const now = new Date();
                
                scores.push({
                    name: playerName,
                    score: score,
                    level: level,
                    difficulty: difficulty,
                    date: now.toLocaleDateString(),
                    timestamp: now.getTime()
                });
                
                // Sort by score (descending)
                scores.sort((a, b) => b.score - a.score);
                
                // Keep only top 10 scores
                if (scores.length > 10) {
                    scores.length = 10;
                }
                
                localStorage.setItem('pacmanHighScores', JSON.stringify(scores));
                highScore = scores[0].score;
            }

            function renderHighScores() {
                const scores = JSON.parse(localStorage.getItem('pacmanHighScores')) || [];
                const tbody = document.getElementById("scores-body");
                tbody.innerHTML = '';
                
                scores.forEach((score, index) => {
                    const row = document.createElement("tr");
                    
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${score.name}</td>
                        <td>${score.score}</td>
                        <td>${score.level}</td>
                        <td>${score.difficulty.charAt(0).toUpperCase() + score.difficulty.slice(1)}</td>
                        <td>${score.date}</td>
                    `;
                    
                    tbody.appendChild(row);
                });
            }

            // Keyboard Controls
            document.addEventListener('keydown', (e) => {
                if (!gameStarted || !pacman.isAlive) return;
                
                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        pacman.updateDirection('up');
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        pacman.updateDirection('down');
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        pacman.updateDirection('left');
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        pacman.updateDirection('right');
                        break;
                    case ' ':
                        if (gameOver) resetGame();
                        break;
                }
            });

            // Prevent arrow keys from scrolling the page
            window.addEventListener('keydown', function(e) {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                }
            });
        </script>
    </body>
</html>
